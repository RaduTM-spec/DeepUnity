#define THREADS_NUM 256

#define FLOAT_MIN -340282346638528859811704183484516925440.0000000000000000f
#define FLOAT_MAX 340282346638528859811704183484516925440.0000000000000000f
#define PI 3.14159265358979323846264338327950288
#define RANDOM_IA 16807
#define RANDOM_IM 2147483647
#define RANDOM_AM (1.0f/float(RANDOM_IM))
#define RANDOM_IQ 127773u
#define RANDOM_IR 2836
#define RANDOM_MASK 123459876


// ------------------------------------------------------------------- Data Fields
RWStructuredBuffer<float> data1;
int w1 = 1;
int h1 = 1;
int c1 = 1;
int b1 = 1;
int r1 = 0;

RWStructuredBuffer<float> data2;
int w2 = 1;
int h2 = 1;
int c2 = 1;
int b2 = 1;
int r2 = 0;

RWStructuredBuffer<float> result;
int wr = 1;
int hr = 1;
int cr = 1;
int br = 1;
int rr = 0;

// Additional fields used for operations
int seed;
int axis;
float value;
float power;
float minvalue;
float maxvalue;
int split_size;
int times;
int correction;
float mu;
float sigma;
float start;
float end;
float step;
// ------------------------------------------------------------------- Data Fields


// ------------------------------------------------------------------Utils
int axisIndex(int axis, int rank)
{
    // negative axis is not handled here
    if (rank == 0)
        return 3 + axis;
    return 4 - rank + axis;

}

void data1_set(int b, int c, int h, int w, float value)
{
    data1[b * c1 * h1 * w1 + c * h1 * w1 + w * h1 + h] = value;
    //data1[b * c1 * h1 * w1 + c * h1 * w1 + h * w1 + w] = value;
}
float data1_get(int b, int c, int h, int w)
{
    return data1[b * c1 * h1 * w1 + c * h1 * w1 + w * h1 + h];
    //return data1[b * c1 * h1 * w1 + c * h1 * w1 + h * w1 + w];
}
void data2_set(int b, int c, int h, int w, float value)
{
    data2[b * c2 * h2 * w2 + c * h2 * w2 + w * h2 + h] = value;
    //data2[b * c2 * h2 * w2 + c * h2 * w2 + h * w2 + w] = value;
}
float data2_get(int b, int c, int h, int w)
{
    return data2[b * c2 * h2 * w2 + c * h2 * w2 + w * h2 + h];
    //return data2[b * c2 * h2 * w2 + c * h2 * w2 + h * w2 + w];
}
void result_set(int b, int c, int h, int w, float value)
{
    result[b * cr * hr * wr + c * hr * wr + w * hr + h] = value;
    //result[b * cr * hr * wr + c * hr * wr + h * wr + w] = value;
}
float result_get(int b, int c, int h, int w)
{
    return result[b * cr * hr * wr + c * hr * wr + w * hr + h];
    //return result[b * cr * hr * wr + c * hr * wr + h * wr + w];
}
float runif()
{
    /// Consider this is not thread safe !!!
    seed ^= 2747636419u;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    return float(seed) / 4294967295.0 + 0.5f;
}
float rnorm(float mean, float sd)
{
    float x1 = 1.0f - runif();
    float x2 = 1.0f - runif();
    
    float e = sqrt(-2.0f * log(x1)) * cos(2.0f * x2 * PI);
    return e * sd + mean;

}
//-------------------------------------------------------------------Utils

// ----------------------------------------------------------------- Kernels

// Create
#pragma kernel Ones
[numthreads(1, 1, 1)]
void Ones(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);

    for (int i = 0; i < count; i++)
    {
        result[i] = 1.0f;

    }
}

#pragma kernel Fill
[numthreads(1, 1, 1)]
void Fill(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);

    for (int i = 0; i < count; i++)
    {
        result[i] = value;

    }
}


#pragma kernel Arange
[numthreads(1, 1, 1)]
void Arange(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);


    int value = start;
    for (int i = 0; i < count; i++)
    {
        result[i] = value;
        
        if (start < end)
            value += step;
        else
            value -= step;
    }
}

#pragma kernel Random01
[numthreads(1, 1, 1)]
void Random01(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);

    for (int i = 0; i < count; i++)
    {
        result[i] = runif();

    }
}

#pragma kernel RandomNormal
[numthreads(1, 1, 1)]
void RandomNormal(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);

    for (int i = 0; i < count; i++)
    {
        result[i] = rnorm(mu, sigma);

    }
}

#pragma kernel RandomRange
[numthreads(1, 1, 1)]
void RandomRange(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);

    for (int i = 0; i < count; i++)
    {
        result[i] = runif() * (maxvalue - minvalue) + minvalue;

    }
}





// Operator overloading
#pragma kernel AdditionElementWise
[numthreads(THREADS_NUM, 1, 1)]
void AdditionElementWise(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);
    
    for (int i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = data1[i] + data2[i];
    }
}

#pragma kernel SubtractionElementWise
[numthreads(THREADS_NUM, 1, 1)]
void SubtractionElementWise(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);
    
    for (int i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = data1[i] - data2[i];
    }
}

#pragma kernel MultiplicationElementWise
[numthreads(THREADS_NUM, 1, 1)]
void MultiplicationElementWise(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);
    
    for (int i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = data1[i] * data2[i];
    }
}

#pragma kernel DivisionElementWise
[numthreads(THREADS_NUM, 1, 1)]
void DivisionElementWise(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);
    
    for (int i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = data1[i] / data2[i];
    }
}

#pragma kernel AdditionWithScalar
[numthreads(THREADS_NUM, 1, 1)]
void AdditionWithScalar(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);
    
    for (int i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = data1[i] + value;
    }
}

#pragma kernel SubtractionWithScalar
[numthreads(THREADS_NUM, 1, 1)]
void SubtractionWithScalar(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);
    
    for (int i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = data1[i] - value;
    }
}

#pragma kernel MultiplicationWithScalar
[numthreads(THREADS_NUM, 1, 1)]
void MultiplicationWithScalar(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);
    
    for (int i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = data1[i] * value;
    }
}

#pragma kernel DivisionWithScalar
[numthreads(THREADS_NUM, 1, 1)]
void DivisionWithScalar(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);
    
    for (int i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = data1[i] / value;
    }
}

#pragma kernel MinElementWise
[numthreads(THREADS_NUM, 1, 1)]
void MinElementWise(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);
    
    for (int i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = min(data1[i], data2[i]);
    }
}

#pragma kernel MaxElementWise
[numthreads(THREADS_NUM, 1, 1)]
void MaxElementWise(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);
    
    for (int i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = max(data1[i], data2[i]);
    }
}

// Special operations
#pragma kernel MatMul
[numthreads(8, 8, 8)]
void MatMul(int3 id : SV_DispatchThreadID)
{   
    // id.x = p , id.y = n, id.z = k
    
    // input [J x 1 x N x M] * other [K x M x P]
    // out [J x K x N x P]
    
    // make sure if id is inside the matrix
    if (id.x >= wr || id.y >= hr || id.z >= cr)
        return;
    
    if(r2 == 1)
    {
        for (int j = 0; j < br; j++)
        {
            float sum = 0.0f;
            for (int m = 0; m < w1; m++)
            {
                float l = data1_get(j, 0, id.y, m);
                float r = data2_get(0, id.z, 0, m);
                sum += l * r;
            }
        
            result_set(j, id.z, 0, id.y, sum);
        }
    }
    else if(r1 == 1)
    {
        for (int j = 0; j < br; j++)
        {
            float sum = 0.0f;
            for (int m = 0; m < w1; m++)
            {
                float l = data1_get(j, 0, 0, m);
                float r = data2_get(0, id.z, m, id.x);
                sum += l * r;
            }
        
            result_set(j, id.z, 0, id.x, sum);
        }
    }
    else
    {      
        for (int j = 0; j < br; j++)
        {
            float sum = 0.0f;
            for (int m = 0; m < w1; m++)
            {
                sum += data1_get(j, 0, id.y, m) * data2_get(0, id.z, m, id.x);
            }
        
            result_set(j, id.z, id.y, id.x, sum);
        }
    }
}



// Operations on matrix
#pragma kernel Mean
[numthreads(1, 1, 1)]
void Mean(int3 id : SV_DispatchThreadID)
{
    int a = axisIndex(axis, r1);
    
    if (a == 3)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int j = 0; j < h1; j++)
                {
                    float sum = 0.0;
                    for (int i = 0; i < w1; i++)
                    {
                        sum += data1_get(l, k, j, i);
                                       
                    }
                    sum /= float(w1);
                    for (int i = 0; i < w1; i++)
                    {
                        result_set(l, k, j, i, sum);
                                       
                    }

                }
            }

        }
    else if (a == 2)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    for (int j = 0; j < h1; j++)
                    {
                        sum += data1_get(l, k, j, i);

                    }
                    sum /= float(h1);
                    for (int j = 0; j < h1; j++)
                    {
                        result_set(l, k, j, i, sum);
                    }
                }
            }
        }
    else if (a == 1)
        for (int l = 0; l < b1; l++)
        {
            for (int j = 0; j < h1; j++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    for (int k = 0; k < c1; k++)
                    {
                        sum += data1_get(l, k, j, i);
                    }
                    sum /= float(c1);
                    for (int k = 0; k < c1; k++)
                    {
                        result_set(l, k, j, i, sum);
                    }
                }
            }
        }
    else if (a == 0)
        for (int k = 0; k < c1; k++)
        {
            for (int j = 0; j < h1; j++)
            {
               
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    for (int l = 0; l < b1; l++)
                    {
                        sum += data1_get(l, k, j, i);
                    }
                    sum /= float(b1);
                    for (int l = 0; l < b1; l++)
                    {
                        result_set(l, k, j, i, sum);
                    }
                   
                }
            }
        }
       

}

#pragma kernel Var
[numthreads(1, 1, 1)]
void Var(int3 id : SV_DispatchThreadID)
{
    int a = axisIndex(axis, r1);
    
    if (a == 3)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int j = 0; j < h1; j++)
                {
                    float sum = 0.0;
                    float sumsqr = 0.0;
                    for (int i = 0; i < w1; i++)
                    {
                        float v = data1_get(l, k, j, i);
                        sum += v;
                        sumsqr += v * v;
                    }
                    float var = (sumsqr - (sum * sum) / float(w1)) / (float(w1) - correction);
                    for (int i = 0; i < w1; i++)
                    {
                        result_set(l, k, j, i, var);
                                       
                    }

                }
            }

        }
    else if (a == 2)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    float sumsqr = 0.0;
                    for (int j = 0; j < h1; j++)
                    {
                        float v = data1_get(l, k, j, i);
                        sum += v;
                        sumsqr += v * v;

                    }
                    float var = (sumsqr - (sum * sum) / float(h1)) / (float(h1) - correction);
                    for (int j = 0; j < h1; j++)
                    {
                        result_set(l, k, j, i, var);
                    }

                }
            }
        }
    else if (a == 1)
        for (int l = 0; l < b1; l++)
        {
            for (int j = 0; j < h1; j++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    float sumsqr = 0.0;
                    for (int k = 0; k < c1; k++)
                    {
                        float v = data1_get(l, k, j, i);
                        sum += v;
                        sumsqr += v * v;
                    }
                    float var = (sumsqr - (sum * sum) / float(c1)) / (float(c1) - correction);
                    for (int k = 0; k < c1; k++)
                    {
                        result_set(l, k, j, i, var);
                    }
                }
            }
        }
    else if (a == 0)
        for (int k = 0; k < c1; k++)
        {
            for (int j = 0; j < h1; j++)
            {
               
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    float sumsqr = 0.0;
                    for (int l = 0; l < b1; l++)
                    {
                        float v = data1_get(l, k, j, i);
                        sum += v;
                        sumsqr += v * v;
                    }
                    float var = (sumsqr - (sum * sum) / float(b1)) / (float(b1) - correction);
                    for (int l = 0; l < b1; l++)
                    {
                        result_set(l, k, j, i, var);
                    }
                   
                }
            }
        }
       

}

#pragma kernel Std
[numthreads(1, 1, 1)]
void Std(int3 id : SV_DispatchThreadID)
{
    int a = axisIndex(axis, r1);
    
    if (a == 3)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int j = 0; j < h1; j++)
                {
                    float sum = 0.0;
                    float sumsqr = 0.0;
                    for (int i = 0; i < w1; i++)
                    {
                        float v = data1_get(l, k, j, i);
                        sum += v;
                        sumsqr += v * v;
                    }
                    float var = (sumsqr - (sum * sum) / float(w1)) / (float(w1) - correction);
                    
                    for (int i = 0; i < w1; i++)
                    {
                        result_set(l, k, j, i, sqrt(var));
                                       
                    }
                }
            }

        }
    else if (a == 2)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    float sumsqr = 0.0;
                    for (int j = 0; j < h1; j++)
                    {
                        float v = data1_get(l, k, j, i);
                        sum += v;
                        sumsqr += v * v;

                    }
                    float var = (sumsqr - (sum * sum) / float(h1)) / (float(h1) - correction);
                    
                    for (int j = 0; j < h1; j++)
                    {
                        result_set(l, k, j, i, sqrt(var));
                    }
                }
            }
        }
    else if (a == 1)
        for (int l = 0; l < b1; l++)
        {
            for (int j = 0; j < h1; j++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    float sumsqr = 0.0;
                    for (int k = 0; k < c1; k++)
                    {
                        float v = data1_get(l, k, j, i);
                        sum += v;
                        sumsqr += v * v;
                    }
                    float var = (sumsqr - (sum * sum) / float(c1)) / (float(c1) - correction);
                    
                    for (int k = 0; k < c1; k++)
                    {
                        result_set(l, k, j, i, sqrt(var));
                    }
                }
            }
        }
    else if (a == 0)
        for (int k = 0; k < c1; k++)
        {
            for (int j = 0; j < h1; j++)
            {
               
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    float sumsqr = 0.0;
                    for (int l = 0; l < b1; l++)
                    {
                        float v = data1_get(l, k, j, i);
                        sum += v;
                        sumsqr += v * v;
                    }
                    float var = (sumsqr - (sum * sum) / float(b1)) / (float(b1) - correction);
                    
                    for (int l = 0; l < b1; l++)
                    {
                        result_set(l, k, j, i, sqrt(var));
                    }                 
                }
            }
        }
       

}

#pragma kernel Sum
[numthreads(1, 1, 1)]
void Sum(int3 id : SV_DispatchThreadID)
{
    int a = axisIndex(axis, r1);
    
    if (a == 3)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int j = 0; j < h1; j++)
                {
                    float sum = 0.0;
                    for (int i = 0; i < w1; i++)
                    {
                        sum += data1_get(l, k, j, i);
                                       
                    }              
                    for (int i = 0; i < w1; i++)
                    {
                        result_set(l, k, j, i, sum);
                                       
                    }
                }
            }

        }
    else if (a == 2)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    for (int j = 0; j < h1; j++)
                    {
                        sum += data1_get(l, k, j, i);

                    }
                    for (int j = 0; j < h1; j++)
                    {
                        result_set(l, k, j, i, sum);

                    }
                }
            }
        }
    else if (a == 1)
        for (int l = 0; l < b1; l++)
        {
            for (int j = 0; j < h1; j++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    for (int k = 0; k < c1; k++)
                    {
                        sum += data1_get(l, k, j, i);
                    }
                    for (int k = 0; k < c1; k++)
                    {
                        result_set(l, k, j, i, sum);
                    }
                }
            }
        }
    else if (a == 0)
        for (int k = 0; k < c1; k++)
        {
            for (int j = 0; j < h1; j++)
            {
               
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    for (int l = 0; l < b1; l++)
                    {
                        sum += data1_get(l, k, j, i);
                    }
                    for (int l = 0; l < b1; l++)
                    {
                        result_set(l, k, j, i, sum);
                    }                   
                }
            }
        }
       

}

#pragma kernel Min
[numthreads(1, 1, 1)]
void Min(int3 id : SV_DispatchThreadID)
{
    int a = axisIndex(axis, r1);
    
    if (a == 3)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int j = 0; j < h1; j++)
                {
                    float m = FLOAT_MAX;
                    for (int i = 0; i < w1; i++)
                    {
                        m = min(m, data1_get(l, k, j, i));
                                       
                    }
                    for (int i = 0; i < w1; i++)
                    {
                        result_set(l, k, j, i, m);
                                       
                    }

                }
            }

        }
    else if (a == 2)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float m = FLOAT_MAX;
                    for (int j = 0; j < h1; j++)
                    {
                        m = min(m, data1_get(l, k, j, i));

                    }
                    for (int j = 0; j < h1; j++)
                    {
                        result_set(l, k, j, i, m);

                    }

                }
            }
        }
    else if (a == 1)
        for (int l = 0; l < b1; l++)
        {
            for (int j = 0; j < h1; j++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float m = FLOAT_MAX;
                    for (int k = 0; k < c1; k++)
                    {
                        m = min(m, data1_get(l, k, j, i));
                    }
                    for (int k = 0; k < c1; k++)
                    {
                        result_set(l, k, j, i, m);
                    }
                }
            }
        }
    else if (a == 0)
        for (int k = 0; k < c1; k++)
        {
            for (int j = 0; j < h1; j++)
            {
               
                for (int i = 0; i < w1; i++)
                {
                    float m = FLOAT_MAX;
                    for (int l = 0; l < b1; l++)
                    {
                        m = min(m, data1_get(l, k, j, i));
                    }
                    for (int l = 0; l < b1; l++)
                    {
                        result_set(l, k, j, i, m);
                    }
                   
                }
            }
        }
       

}

#pragma kernel Max
[numthreads(1, 1, 1)]
void Max(int3 id : SV_DispatchThreadID)
{
    int a = axisIndex(axis, r1);
    
    if (a == 3)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int j = 0; j < h1; j++)
                {
                    float m = FLOAT_MIN;
                    for (int i = 0; i < w1; i++)
                    {
                        m = max(m, data1_get(l, k, j, i));
                                       
                    }
                    for (int i = 0; i < w1; i++)
                    {
                        result_set(l, k, j, i, m);
                                       
                    }
                }
            }

        }
    else if (a == 2)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float m = FLOAT_MIN;
                    for (int j = 0; j < h1; j++)
                    {
                        m = max(m, data1_get(l, k, j, i));

                    }
                    for (int j = 0; j < h1; j++)
                    {
                        result_set(l, k, j, i, m);

                    }

                }
            }
        }
    else if (a == 1)
        for (int l = 0; l < b1; l++)
        {
            for (int j = 0; j < h1; j++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float m = FLOAT_MIN;
                    for (int k = 0; k < c1; k++)
                    {
                        m = max(m, data1_get(l, k, j, i));
                    }
                    for (int k = 0; k < c1; k++)
                    {
                        result_set(l, k, j, i, m);
                    }
                }
            }
        }
    else if (a == 0)
        for (int k = 0; k < c1; k++)
        {
            for (int j = 0; j < h1; j++)
            {
               
                for (int i = 0; i < w1; i++)
                {
                    float m = FLOAT_MIN;
                    for (int l = 0; l < b1; l++)
                    {
                        m = max(m, data1_get(l, k, j, i));
                    }
                    for (int l = 0; l < b1; l++)
                    {
                        result_set(l, k, j, i, m);
                    }
                   
                }
            }
        }
       

}





// Math operations

#pragma kernel Pow
[numthreads(THREADS_NUM, 1, 1)]
void Pow(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);
    
    for (int i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = pow(data1[i], power);
    }
}

#pragma kernel Sqrt
[numthreads(THREADS_NUM, 1, 1)]
void Sqrt(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);
    
    for (int i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = sqrt(data1[i]);

    }
}

#pragma kernel Log
[numthreads(THREADS_NUM, 1, 1)]
void Log(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);
    
    for (int i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = log(data1[i]);
    }
}

#pragma kernel Exp
[numthreads(THREADS_NUM, 1, 1)]
void Exp(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);
    
    for (int i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = exp(data1[i]);
    }
}

#pragma kernel Sin
[numthreads(THREADS_NUM, 1, 1)]
void Sin(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);
    
    for (int i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = sin(data1[i]);
    }
}

#pragma kernel Cos
[numthreads(THREADS_NUM, 1, 1)]
void Cos(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);
    
    for (int i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = cos(data1[i]);
    }
}

#pragma kernel Abs
[numthreads(THREADS_NUM, 1, 1)]
void Abs(int3 id : SV_DispatchThreadID)
{
    uint count;

    uint stride;
    result.GetDimensions(count, stride);
    
    for (int i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = abs(data1[i]);
    }
}
