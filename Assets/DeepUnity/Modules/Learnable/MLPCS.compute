
void activate(RWStructuredBuffer<float> data, int activation)
{
    uint stride;
    uint count;
    data.GetDimensions(count, stride);
    for (uint i = 0; i < count; i++)
    {
        if (activation == 0)
        {
            if (data[i] < 0)
                data[i] = 0;
        }
        else
        {
            data[i] = (exp(data[i]) - exp(-data[i])) / (exp(data[i]) + exp(-data[i]));
        }

    }
}
void prime(RWStructuredBuffer<float> data, int activation)
{
    uint stride;
    uint count;
    data.GetDimensions(count, stride);
    for (uint i = 0; i < count; i++)
    {
        if (activation == 0)
        {
            if (data[i] < 0)
                data[i] = 0;
            else
                data[i] = 1;
        }
        else
        {
            float e2x = exp(2.0f * data[i]);
            float tanh = (e2x - 1.0f) / (e2x + 1.0f);
            data[i] = 1.0 - tanh * tanh;
        }

    }
}



RWStructuredBuffer<int2> dim1;
RWStructuredBuffer<int2> dim2;
RWStructuredBuffer<int2> dim3;
RWStructuredBuffer<float> weights1; 
RWStructuredBuffer<float> weights2;
RWStructuredBuffer<float> weights3;
RWStructuredBuffer<float> biases1;
RWStructuredBuffer<float> biases2;
RWStructuredBuffer<float> biases3;
RWStructuredBuffer<int> activation; // 0 for ReLU, 1 for Tanh

RWStructuredBuffer<float> input;
RWStructuredBuffer<int2> in_dim;
RWStructuredBuffer<float> output;
RWStructuredBuffer<int2> out_dim;

int index_of_layer_to_compute;


#pragma kernel Predict
[numthreads(32,32,1)]
void Predict (uint3 id : SV_DispatchThreadID)
{
    
}

