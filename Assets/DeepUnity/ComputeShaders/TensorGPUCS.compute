
#define THREADS_NUM 256

#define FLOAT_MIN -340282346638528859811704183484516925440.0000000000000000f
#define FLOAT_MAX 340282346638528859811704183484516925440.0000000000000000f
#define PI 3.14159265358979323846264338327950288
#define RANDOM_IA 16807
#define RANDOM_IM 2147483647
#define RANDOM_AM (1.0f/float(RANDOM_IM))
#define RANDOM_IQ 127773u
#define RANDOM_IR 2836
#define RANDOM_MASK 123459876


// ------------------------------------------------------------------- Data Fields
RWStructuredBuffer<float> data1;
int w1 = 1;
int h1 = 1;
int c1 = 1;
int b1 = 1;
int r1 = 0;

RWStructuredBuffer<float> data2;
int w2 = 1;
int h2 = 1;
int c2 = 1;
int b2 = 1;
int r2 = 0;

RWStructuredBuffer<float> result;
int wr = 1;
int hr = 1;
int cr = 1;
int br = 1;
int rr = 0;

// Additional fields used for operations
int seed;
int axis;
float value;
bool keepDim;
float power;
float minvalue;
float maxvalue;
int split_size;
int times;
int correction;
float mu;
float sigma;
float start;
float end;
float step;
// ------------------------------------------------------------------- Data Fields


// ------------------------------------------------------------------Utils
int axisIndex(int axis, int rank)
{
    // negative axis is not handled here
    if (rank == 0)
        return 3 + axis;
    return 4 - rank + axis;

}

void data1_set(int b, int c, int h, int w, float value)
{
    data1[b * c1 * h1 * w1 + c * h1 * w1 + h * w1 + w] = value;
}
float data1_get(int b, int c, int h, int w)
{
    return data1[b * c1 * h1 * w1 + c * h1 * w1 + h * w1 + w];
}
void data2_set(int b, int c, int h, int w, float value)
{
    data2[b * c2 * h2 * w2 + c * h2 * w2 + h * w2 + w] = value;
}
float data2_get(int b, int c, int h, int w)
{
    return data2[b * c2 * h2 * w2 + c * h2 * w2 + h * w2 + w];
}
void result_set(int b, int c, int h, int w, float value)
{
    result[b * cr * hr * wr + c * hr * wr + h * wr + w] = value;
}
float result_get(int b, int c, int h, int w)
{
    return result[b * cr * hr * wr + c * hr * wr + h * wr + w];
}
float runif()
{
    /// Consider this is not thread safe !!!
    seed ^= 2747636419u;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    return float(seed) / 4294967295.0 + 0.5f;
}
float rnorm(float mean, float sd)
{
    float x1 = 1.0f - runif();
    float x2 = 1.0f - runif();
    
    float e = sqrt(-2.0f * log(x1)) * cos(2.0f * x2 * PI);
    return e * sd + mean;

}
//-------------------------------------------------------------------Utils

// ----------------------------------------------------------------- Kernels

// Create
#pragma kernel Ones
[numthreads(1, 1, 1)]
void Ones(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);

    for (uint i = 0; i < count; i++)
    {
        result[i] = 1.0f;

    }
}

#pragma kernel Arange
[numthreads(1, 1, 1)]
void Arange(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);


    int value = start;
    for (uint i = 0; i < count; i++)
    {
        result[i] = value;
        
        if (start < end)
            value += step;
        else 
            value -= step;
    }  
}

#pragma kernel Random01
[numthreads(1, 1, 1)]
void Random01(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);

    for (uint i = 0; i < count; i++)
    {
        result[i] = runif();

    }
}

#pragma kernel RandomNormal
[numthreads(1, 1, 1)]
void RandomNormal(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);

    for (uint i = 0; i < count; i++)
    {
        result[i] = rnorm(mu, sigma);

    }
}


// Operator overloading
#pragma kernel AdditionElementWise
[numthreads(THREADS_NUM, 1, 1)]
void AdditionElementWise(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);
    
    for (uint i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = data1[i] + data2[i];
    }
}

#pragma kernel SubtractionElementWise
[numthreads(THREADS_NUM,1,1)]
void SubtractionElementWise(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);
    
    for (uint i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = data1[i] - data2[i];
    }
}

#pragma kernel MultiplicationElementWise
[numthreads(THREADS_NUM, 1, 1)]
void MultiplicationElementWise(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);
    
    for (uint i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = data1[i] * data2[i];
    }
}

#pragma kernel DivisionElementWise
[numthreads(THREADS_NUM, 1, 1)]
void DivisionElementWise(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);
    
    for (uint i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = data1[i] / data2[i];
    }
}

#pragma kernel AdditionWithScalar
[numthreads(THREADS_NUM, 1, 1)]
void AdditionWithScalar(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);
    
    for (uint i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = data1[i] + value;
    }
}

#pragma kernel SubtractionWithScalar
[numthreads(THREADS_NUM, 1, 1)]
void SubtractionWithScalar(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);
    
    for (uint i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = data1[i] - value;
    }
}

#pragma kernel MultiplicationWithScalar
[numthreads(THREADS_NUM, 1, 1)]
void MultiplicationWithScalar(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);
    
    for (uint i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = data1[i] * value;
    }
}

#pragma kernel DivisionWithScalar
[numthreads(THREADS_NUM, 1, 1)]
void DivisionWithScalar(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);
    
    for (uint i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = data1[i] / value;
    }
}

#pragma kernel MinElementWise
[numthreads(THREADS_NUM, 1, 1)]
void MinElementWise(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);
    
    for (uint i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = min(data1[i], data2[i]);
    }
}

#pragma kernel MaxElementWise
[numthreads(THREADS_NUM, 1, 1)]
void MaxElementWise(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);
    
    for (uint i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = max(data1[i], data2[i]);
    }
}


// Special operations
#pragma kernel MatMul
[numthreads(8,8,8)]
void MatMul(uint3 id : SV_DispatchThreadID)
{
    if (id.x < h1 && (w2 == 1 || id.y < w2))
        for (int l = 0; l < b1; l++)
        {
            float sum = 0.0f;
            for (uint i = 0; i < w1; i++)
            {
                sum += data1_get(l, id.z, id.y, i) * data2_get(l, id.z, i, id.x);
               
                
            }
            result_set(l, id.z, id.y, id.x, sum);
        }
}



// Operations on matrix
#pragma kernel Mean
[numthreads(1, 1, 1)]
void Mean(uint3 id : SV_DispatchThreadID)
{
    int a = axisIndex(axis, r1);
    
    if (a == 3)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int j = 0; j < h1; j++)
                {
                    float sum = 0.0;
                    for (int i = 0; i < w1; i++)
                    {
                        sum += data1_get(l, k, j, i);
                                       
                    }
                    sum /= float(w1);
                    if (keepDim)
                    {
                        result_set(l, k, j, i, sum);
                    }
                    else
                    {
                        result_set(l, k, j, 0, sum);
                    }

                }
            }

        }
    else if(a == 2)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    for (int j = 0; j < h1; j++)
                    {
                        sum += data1_get(l, k, j, i);

                    }    
                    sum /= float(h1);
                    if (keepDim)
                    {
                        result_set(l, k, j, i, sum);
                    }
                    else
                    {
                        result_set(l, k, 0, i, sum);
                    }

                }
            }
        }
    else if(a == 1)
        for (int l = 0; l < b1; l++)
        {
            for (int j = 0; j < h1; j++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    for (int k = 0; k < c1; k++)
                    {
                        sum += data1_get(l, k, j, i);
                    }
                    sum /= float(c1);
                    if (keepDim)
                    {
                        result_set(l, k, j, i, sum);
                    }
                    else
                    {
                        result_set(l, 0, j, i, sum);
                    }
                }
            }
        }
    else if(a == 0)
        for (int k = 0; k < c1; k++)
        {
            for (int j = 0; j < h1; j++)
            {
               
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    for (int l = 0; l < b1; l++)
                    {
                        sum += data1_get(l, k, j, i);
                    }
                    sum /= float(b1);
                    if(keepDim)
                    {
                        result_set(l, k, j, i, sum);
                    }
                    else
                    {
                        result_set(0, k, j, i, sum);
                    }
                   
                }
            }
        }
       

}

#pragma kernel Var
[numthreads(1, 1, 1)]
void Var(uint3 id : SV_DispatchThreadID)
{
    int a = axisIndex(axis, r1);
    
    if (a == 3)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int j = 0; j < h1; j++)
                {
                    float sum = 0.0;
                    float sumsqr = 0.0;
                    for (int i = 0; i < w1; i++)
                    {
                        float v= data1_get(l, k, j, i);
                        sum += v;
                        sumsqr += v * v;
                    }
                    float var = (sumsqr - (sum * sum) / float(w1)) / (float(w1) - correction);
                    if (keepDim)
                    {
                        result_set(l, k, j, i, var);
                    }
                    else
                    {
                        result_set(l, k, j, 0, var);
                    }

                }
            }

        }
    else if (a == 2)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    float sumsqr = 0.0;
                    for (int j = 0; j < h1; j++)
                    {
                        float v = data1_get(l, k, j, i);
                        sum += v;
                        sumsqr += v * v;

                    }
                    float var = (sumsqr - (sum * sum) / float(h1)) / (float(h1) - correction);
                    if (keepDim)
                    {
                        result_set(l, k, j, i, var);
                    }
                    else
                    {
                        result_set(l, k, 0, i, var);
                    }

                }
            }
        }
    else if (a == 1)
        for (int l = 0; l < b1; l++)
        {
            for (int j = 0; j < h1; j++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    float sumsqr = 0.0;
                    for (int k = 0; k < c1; k++)
                    {
                        float v = data1_get(l, k, j, i);
                        sum += v;
                        sumsqr += v * v;
                    }
                    float var = (sumsqr - (sum * sum) / float(c1)) / (float(c1) - correction);
                    if (keepDim)
                    {
                        result_set(l, k, j, i, var);
                    }
                    else
                    {
                        result_set(l, 0, j, i, var);
                    }
                }
            }
        }
    else if (a == 0)
        for (int k = 0; k < c1; k++)
        {
            for (int j = 0; j < h1; j++)
            {
               
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    float sumsqr = 0.0;
                    for (int l = 0; l < b1; l++)
                    {
                        float v = data1_get(l, k, j, i);
                        sum += v;
                        sumsqr += v * v;
                    }
                    float var = (sumsqr - (sum * sum) / float(b1)) / (float(b1) - correction);
                    if (keepDim)
                    {
                        result_set(l, k, j, i, var);
                    }
                    else
                    {
                        result_set(0, k, j, i, var);
                    }
                   
                }
            }
        }
       

}

#pragma kernel Std
[numthreads(1, 1, 1)]
void Std(uint3 id : SV_DispatchThreadID)
{
    int a = axisIndex(axis, r1);
    
    if (a == 3)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int j = 0; j < h1; j++)
                {
                    float sum = 0.0;
                    float sumsqr = 0.0;
                    for (int i = 0; i < w1; i++)
                    {
                        float v = data1_get(l, k, j, i);
                        sum += v;
                        sumsqr += v * v;
                    }
                    float var = (sumsqr - (sum * sum) / float(w1)) / (float(w1) - correction);
                    if (keepDim)
                    {
                        result_set(l, k, j, i, sqrt(var));
                    }
                    else
                    {
                        result_set(l, k, j, 0, sqrt(var));
                    }

                }
            }

        }
    else if (a == 2)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    float sumsqr = 0.0;
                    for (int j = 0; j < h1; j++)
                    {
                        float v = data1_get(l, k, j, i);
                        sum += v;
                        sumsqr += v * v;

                    }
                    float var = (sumsqr - (sum * sum) / float(h1)) / (float(h1) - correction);
                    if (keepDim)
                    {
                        result_set(l, k, j, i, sqrt(var));
                    }
                    else
                    {
                        result_set(l, k, 0, i, sqrt(var));
                    }

                }
            }
        }
    else if (a == 1)
        for (int l = 0; l < b1; l++)
        {
            for (int j = 0; j < h1; j++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    float sumsqr = 0.0;
                    for (int k = 0; k < c1; k++)
                    {
                        float v = data1_get(l, k, j, i);
                        sum += v;
                        sumsqr += v * v;
                    }
                    float var = (sumsqr - (sum * sum) / float(c1)) / (float(c1) - correction);
                    if (keepDim)
                    {
                        result_set(l, k, j, i, sqrt(var));
                    }
                    else
                    {
                        result_set(l, 0, j, i, sqrt(var));
                    }
                }
            }
        }
    else if (a == 0)
        for (int k = 0; k < c1; k++)
        {
            for (int j = 0; j < h1; j++)
            {
               
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    float sumsqr = 0.0;
                    for (int l = 0; l < b1; l++)
                    {
                        float v = data1_get(l, k, j, i);
                        sum += v;
                        sumsqr += v * v;
                    }
                    float var = (sumsqr - (sum * sum) / float(b1)) / (float(b1) - correction);
                    if (keepDim)
                    {
                        result_set(l, k, j, i, sqrt(var));
                    }
                    else
                    {
                        result_set(0, k, j, i, sqrt(var));
                    }
                   
                }
            }
        }
       

}

#pragma kernel Sum
[numthreads(1, 1, 1)]
void Sum(uint3 id : SV_DispatchThreadID)
{
    int a = axisIndex(axis, r1);
    
    if (a == 3)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int j = 0; j < h1; j++)
                {
                    float sum = 0.0;
                    for (int i = 0; i < w1; i++)
                    {
                        sum += data1_get(l, k, j, i);
                                       
                    }
                    if (keepDim)
                    {
                        result_set(l, k, j, i, sum);
                    }
                    else
                    {
                        result_set(l, k, j, 0, sum);
                    }

                }
            }

        }
    else if (a == 2)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    for (int j = 0; j < h1; j++)
                    {
                        sum += data1_get(l, k, j, i);

                    }
                    if (keepDim)
                    {
                        result_set(l, k, j, i, sum);
                    }
                    else
                    {
                        result_set(l, k, 0, i, sum);
                    }

                }
            }
        }
    else if (a == 1)
        for (int l = 0; l < b1; l++)
        {
            for (int j = 0; j < h1; j++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    for (int k = 0; k < c1; k++)
                    {
                        sum += data1_get(l, k, j, i);
                    }
                    if (keepDim)
                    {
                        result_set(l, k, j, i, sum);
                    }
                    else
                    {
                        result_set(l, 0, j, i, sum);
                    }
                }
            }
        }
    else if (a == 0)
        for (int k = 0; k < c1; k++)
        {
            for (int j = 0; j < h1; j++)
            {
               
                for (int i = 0; i < w1; i++)
                {
                    float sum = 0.0;
                    for (int l = 0; l < b1; l++)
                    {
                        sum += data1_get(l, k, j, i);
                    }
                    if (keepDim)
                    {
                        result_set(l, k, j, i, sum);
                    }
                    else
                    {
                        result_set(0, k, j, i, sum);
                    }
                   
                }
            }
        }
       

}

#pragma kernel Min
[numthreads(1, 1, 1)]
void Min(uint3 id : SV_DispatchThreadID)
{
    int a = axisIndex(axis, r1);
    
    if (a == 3)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int j = 0; j < h1; j++)
                {
                    float m = FLOAT_MAX;
                    for (int i = 0; i < w1; i++)
                    {
                        m = min(m, data1_get(l, k, j, i));
                                       
                    }
                    if (keepDim)
                    {
                        result_set(l, k, j, i, m);
                    }
                    else
                    {
                        result_set(l, k, j, 0, m);
                    }

                }
            }

        }
    else if (a == 2)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float m = FLOAT_MAX;
                    for (int j = 0; j < h1; j++)
                    {
                        m = min(m, data1_get(l, k, j, i));

                    }
                    if (keepDim)
                    {
                        result_set(l, k, j, i, m);
                    }
                    else
                    {
                        result_set(l, k, 0, i, m);
                    }

                }
            }
        }
    else if (a == 1)
        for (int l = 0; l < b1; l++)
        {
            for (int j = 0; j < h1; j++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float m = FLOAT_MAX;
                    for (int k = 0; k < c1; k++)
                    {
                        m = min(m, data1_get(l, k, j, i));
                    }
                    if (keepDim)
                    {
                        result_set(l, k, j, i, m);
                    }
                    else
                    {
                        result_set(l, 0, j, i, m);
                    }
                }
            }
        }
    else if (a == 0)
        for (int k = 0; k < c1; k++)
        {
            for (int j = 0; j < h1; j++)
            {
               
                for (int i = 0; i < w1; i++)
                {
                    float m = FLOAT_MAX;
                    for (int l = 0; l < b1; l++)
                    {
                        m = min(m, data1_get(l, k, j, i));
                    }
                    if (keepDim)
                    {
                        result_set(l, k, j, i, m);
                    }
                    else
                    {
                        result_set(0, k, j, i, m);
                    }
                   
                }
            }
        }
       

}

#pragma kernel Max
[numthreads(1, 1, 1)]
void Max(uint3 id : SV_DispatchThreadID)
{
    int a = axisIndex(axis, r1);
    
    if (a == 3)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int j = 0; j < h1; j++)
                {
                    float m = FLOAT_MIN;
                    for (int i = 0; i < w1; i++)
                    {
                        m = max(m, data1_get(l, k, j, i));
                                       
                    }
                    if (keepDim)
                    {
                        result_set(l, k, j, i, m);
                    }
                    else
                    {
                        result_set(l, k, j, 0, m);
                    }

                }
            }

        }
    else if (a == 2)
        for (int l = 0; l < b1; l++)
        {
            for (int k = 0; k < c1; k++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float m = FLOAT_MIN;
                    for (int j = 0; j < h1; j++)
                    {
                        m = max(m, data1_get(l, k, j, i));

                    }
                    if (keepDim)
                    {
                        result_set(l, k, j, i, m);
                    }
                    else
                    {
                        result_set(l, k, 0, i, m);
                    }

                }
            }
        }
    else if (a == 1)
        for (int l = 0; l < b1; l++)
        {
            for (int j = 0; j < h1; j++)
            {
                for (int i = 0; i < w1; i++)
                {
                    float m = FLOAT_MIN;
                    for (int k = 0; k < c1; k++)
                    {
                        m = max(m, data1_get(l, k, j, i));
                    }
                    if (keepDim)
                    {
                        result_set(l, k, j, i, m);
                    }
                    else
                    {
                        result_set(l, 0, j, i, m);
                    }
                }
            }
        }
    else if (a == 0)
        for (int k = 0; k < c1; k++)
        {
            for (int j = 0; j < h1; j++)
            {
               
                for (int i = 0; i < w1; i++)
                {
                    float m = FLOAT_MIN;
                    for (int l = 0; l < b1; l++)
                    {
                        m = max(m, data1_get(l, k, j, i));
                    }
                    if (keepDim)
                    {
                        result_set(l, k, j, i, m);
                    }
                    else
                    {
                        result_set(0, k, j, i, m);
                    }
                   
                }
            }
        }
       

}





// Math operations

#pragma kernel Pow
[numthreads(THREADS_NUM, 1, 1)]
void Pow(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);
    
    for (uint i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = pow(data1[i], power);
    }
}

#pragma kernel Sqrt
[numthreads(THREADS_NUM, 1, 1)]
void Sqrt(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);
    
    for (uint i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = sqrt(data1[i]);

    }
}

#pragma kernel Log
[numthreads(THREADS_NUM, 1, 1)]
void Log(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);
    
    for (uint i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = log(data1[i]); 
    }
}

#pragma kernel Exp
[numthreads(THREADS_NUM, 1, 1)]
void Exp(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);
    
    for (uint i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = exp(data1[i]);
    }
}

#pragma kernel Sin
[numthreads(THREADS_NUM, 1, 1)]
void Sin(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);
    
    for (uint i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = sin(data1[i]);
    }
}

#pragma kernel Cos
[numthreads(THREADS_NUM, 1, 1)]
void Cos(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);
    
    for (uint i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = cos(data1[i]);
    }
}

#pragma kernel Abs
[numthreads(THREADS_NUM, 1, 1)]
void Abs(uint3 id : SV_DispatchThreadID)
{
    uint count;
    uint stride;
    result.GetDimensions(count, stride);
    
    for (uint i = id.x; i < count; i += THREADS_NUM)
    {
        result[i] = abs(data1[i]);
    }
}